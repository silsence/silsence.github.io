# C语言知识点

## 知识点一

### 常用数据类型

    1. 整型:int
        int a=123;

    2. 单精度浮点型:float
        float a=123.0;

    3. 双精度浮点型:double
        double a=123.0;

    4. 字符型:char
        char a='x';
    
    5. 布尔型:bool
        bool a=true;
    
    类型宽度:
    int:    2 <= short <= int <= long
    float:  4
    double: 8
    char:   1
    bool:   1

    强制转换数据类型:
    (类型名)(表达式)
        1. 把a转换为double类型
            (double)a
        2. 把a+b的值转换为整型
            (int)(a+b)

    需要注意的是:如果强制类型转换的对象是一个变量,那么该变量不需要用括号括起来
    但是如果对象是一个包含多项的表达式，则表达式应该用括号括起来
    
    1. 把a+b的值转换为整型
        (int)(a+b)
    2. 把a的值转换为整型,然后加b
        (int)a+b

### 输入输出
    输入:scanf();
        scanf("%d",&x);通过&获取x的值
    输出:printf();
        printf("%d",x);通过格式控制符'%d'输出x的值

    1. scanf的写法
        scanf遇到空白字符(空格，回车，制表符)会结束
        scanf会尽可能读取更多的有效数字到变量,不能写成%.1f,会发生错误,应该写成%f;

    2. print的写法
        print输出是可以加上%.1f,表示输出

    c语言中,%s用来输入字符串 : scanf("%s",&name);

    3. 其他的输入:

        getchar():读取一个缓冲区的字符,可循环使用来清空缓冲区剩余字符直到EOF
        例:
            char c;
            c=getchar();

        get():读取一行字符串，遇到换行或者结束符停止

    4. 其他的输出：
        puts():用于输出一个以 NULL 结尾的字符串，并自动添加换行符。
        例: 
            puts("Hello, World!");

        putc():用于输出单个字符。

### 函数的作用域
    1. 全局变量:在所有函数外部声明的变量
        全局变量的作用域是整个外部空间，直到程序结束才被销毁

    2. 局部变量:在函数或一个代码块内部声明的变量
        局部变量的作用域只在当前创建的函数内部或者代码块里,执行完后就被销毁
        局部变量与全局变量同名时,局部变量优先使用
    
    3. 作用域遵循就近原则，如果在当前作用域找到了同名变量，就不会去更大的作用域查找
    
    4. 如果给static关键字加到全局变量上，那作用域只能在当前文件
### 运算符
1. 常用的运算符
    | 运算符名 | 作用 | 示例 |
    | :---- | :----- | :---- |
    | +	| 把两个操作数相加 | (2 + 3) 将得到 5 |
    | -	| 从第一个操作数中减去第二个操作数 | (5 - 3) 将得到 2|
    | *	| 把两个操作数相乘 | (2 * 3) 将得到 6 |
    | /	| 分子除以分母 | (4 / 3) 将得到 1 |
    | %	| 取模运算符，整除后的余数 | (2 % 3) 将得到 0 |
    | ++ | 自增运算符，整数值增加 1 | ++a:先加后算,a++:先算后加 |
    | -- | 自减运算符，整数值减少 1 | --a:先减后算,a--:先算后减 |
    | == | 检查两个操作数的值是否相等,如果相等则为真 | (2 == 1) 为假 |
    | != | 检查两个操作数的值是否相等,如果不相等则为真 | (2 != 1) 为真 |
    | >	| 检查左操作数的值是否大于右操作数的值,如果是则为真 | (1 > 2) 为假 |
    | <	| 检查左操作数的值是否小于右操作数的值,如果是则为真	| (1 < 2) 为真 |
    | >= | 检查左操作数的值是否大于或等于右操作数的值,如果是则为真 | (1 >= 2) 为假 |
    | <= | 检查左操作数的值是否小于或等于右操作数的值,如果是则为真 | (1 <= 2) 为真 |
    | && | 逻辑与运算符,如果两个操作数都不为假,则为真 | (2 && 0) 为假 |
    | || | 逻辑或运算符,如果两个操作数中任意一个为真,则为真 | (2 || 0) 为真 |
    | !	| 逻辑非运算符,用来反转操作数的逻辑状态,把真的变假，把假的变真| (!0) 为真 |
    | = | 赋值运算符,将运算符右边的值传递给左边 | x=3+2 |
    | +=,-= | 加减运算和赋值运算的简写 | (a = a + 2) a += 2 |
    | ? : |条件表达式,如果条件为真?则值为X,否则值为Y | (2>1 ? a=2 : a=1),条件成立,a=2 |
    | *=,/=,%= | 乘除取余运算和赋值运算的简写 | (a = a * 2) a *= 2 |
    | &	| 返回变量的地址 | &a; 将给出变量的实际地址 |
    | * | 指向一个变量 | *a; 将指向一个变量 |    
### 位移运算符
    "|"把末尾的最后一位变为1,如果要为0就减去1

    异或' ^ ',相同为0,不同为1,a^b=(a AND (NOT b)) OR ((NOT a) AND b)

    取反' ~ ',每一位都取反,包括符号位取反,

    左移' << ',a<< b,把a左移b位，相当于a乘2的b次方,a<<1相当于乘了2

    右移' >> ',a>> b,把a右移b位,相当于a除2的b次方,a>>1相当于除了2,判断正负时,右移31位,可以得到符号位来判断正负

    a=a&(a-1)将a的最右位变为0;

    格雷码，自然二进制数在高位补0,相邻2位之间做或运算,B=0 0101转为G=0111

    格雷码还原为二进制码，将格雷码高位补0,相邻之间的数做异或比较,G=0 1010转为B=1100

    %hd: short int,%hx,x表示输出16进制字母时是否大写，加上#代表输出前缀

    转义字符只能以8进制和16进制。"\"开头表示8进制,"\x"表示16进制
### 函数
    函数的声明:
        函数声明写在函数定义前面,与定义一样,加分号
            返回类型 函数名(形参列表);

    函数的定义:
        返回类型 函数名(形参列表){
            函数体
        }

    return语句是结束函数的唯一方法

#### 常用的数学函数
1.
    | 函数名 | 返回值 |
    | :---- | :----- |
    | 求平方pow(base,n) | 返回double类型 |
    | 求根sqrt(n) | 返回double类型 |
    | 求绝对值fabs(n) | 返回double类型 |
    | cos(double x) | 接受弧度值,返回余弦 |
    | sin(double x) | 接受弧度值,返回正弦 |

#### 字符串的操作函数
- strlen(): 计算字符串长度
- strcpy(a1,a2): 将a2复制到a1，同时'\0'也被复制
- strcat(a1,a2): 将a2剪切到a1后面，删掉a1的'\0'
- strcmp(a1,a2): 比较a1和a2，相同则0，若a1大于a2，则返回大于0的值，否则，返回小于0的值
- strstr(a1,a2): 在a1里查找子串a2,返回第一次出现子串位置的指针,找不到返回NULL
- strtok(a1,a2): 分割字符串a1,使用给定的分隔符a2,每次调用都会返回下一个分隔后的子串

### 数组
    数组是一种数据结构,存储一个固定大小的相同类型元素的顺序集合

    声明时,数组的元素下标必须是一个大于零的整数常量,数组的第一个下标从0开始

    数组的内存是连续的

    字符串数组读取时，不需要添加&，字符串数组名字使用时会转变为地址

    定义:
        定义一个大小为10的整形数组，元素位置为a[0]~a[9]
            int a[10];
    初始化:
        数组的元素全部初始化为0,初始化元素确定时可以不写下标
            int a[10]={0};
            int a[]={0,0,0};
    获取数组长度:
        通过sizeof()获取数组的全部内存大小,再除以单个元素的内存大小,得到数组的个数
        int length = sizeof(array) / sizeof(array[0]);
### 枚举
    枚举是一种基本数据类型,用于定义一组具有离散值的常量,它可以让数据更简洁,更易读

    在C语言中,枚举类型是被当做 int 或者 unsigned int 类型来处理的
    
    没有指定值的枚举元素，其值为前一元素加 1

    定义:
        enum　枚举名　{枚举元素1,枚举元素2,……};

    使用:
        没有指定后面元素的值,TUE值是MON加1,
        enum DAY{
            MON=1, TUE, WED, THU, FRI, SAT, SUN
        };
    先定义类型,在定义变量
        enum DAY{
            MON=1, TUE, WED, THU, FRI, SAT, SUN
        };
        enum DAY day;

### 结构体
    结构是一种用户自定义的可用的数据类型,它允许存储不同类型的数据项

    定义:
        结构体定义由关键字 struct 和结构体名组成，结构体名可以根据需要自行定义。
            struct 结构体名 {
                变量1;
                变量2;
                变量2;
            } 结构体变量列表;

    例:
        struct student{
            char  name[6];
            char  age[2];
            int   id;
        } xs1,xs2;

### typedf
    使用typedef关键字,可以为类型取一个新的名字
    例:
        1. 将unsigned char取别名为UC
            typedef unsigned char UC;

        2. 将结果体名字Books,取名为book
            typedef struct Books
            {
                char  title[5];
                char  author[5];
                char  subject[1];
                int   book_id;
            } book;

## 知识二

### 内存的区域
1.
    程序运行前，只有代码区和全局区，程序运行后，有堆区和栈区
    | 名称   | 作用  |
    | :---- | :----- |
    | 栈区   | 由编译器自动分配和释放，存放函数参数，局部变量等 |
    | 堆区   | 如malloc,由程序员分配释放，若程序员未释放，则程序结束之后，编译器自动释放 |
    | 全局区 | 存放全局变量，静态变量以及常量 |
    | 代码区 | 存放函数体内的二进制代码，有操作系统管理 |

### 指针的使用
    定义指针变量的'*'和使用的'*'是完全不同的，给指 针变量赋值时，不加'*'号

    "*"号有3种表示方法: 
    1. 表示乘法
    2. 表示定义一个指针变量
    3. 表示获取指针的数据，是一种间接操作

    求数组长度时，不能使用sizeof(p)/sizeof(int),
    因为P指向的只是一个指针，不知道指针指向的是一个数还是一个数组，所以求得的只能时p本身的地址字节数，

    数组名是常量，不能改变值，不能写成:*arr++,arr是数组名，++会改变值
    向下取整，a+(b-1)/b

### 动态空间的开辟与释放

    开辟动态空间:
        返回值类型void* ,参数要开辟空间的字节数
        例:    void* malloc(size_t size);

        开辟成功,返回开辟好的指针,开辟失败,返回开辟NULL指针

        使用:
            不知道返回的类型,需要手动指定类型
                int *pa = (int*)malloc(40);
    
    释放动态空间:
        使用free释放后,虽然释放了但依旧具有起始地址,所以要为空
        void free (void* ptr);
        例:     free(pa);
                pa = NULL;
	
	malloc()仅分配内存而不进行初始化。
	calloc()不仅分配内存，还会对分配到的内存区域执行清零操作，这对于需要初始化为0的数据结构特别有用。

### 链表
    链表的第一个头节点并不存储数据，只是作为进入链表的入口点，提供起始位置

    单向链表的头插法
    NewNode->next = HeadNode->next;
    HeadNode->next = NewNode;

    单向链表的尾插法:
    HeadNode->next = NewNode;
	NewNode->next = NULL;

    单向链表的删除:
    DeleteNodefront=head;删除节点的前一个节点
    DeleteNode=head->next;需要删除的节点
    DeleteNode->next;删除节点的后一个节点
    DeleteNodeFront->next = DeleteNode->next;被删除节点的前一个节点连接到被删节点的后一个节点
	free(DeleteNode);释放中间这个被删节点
